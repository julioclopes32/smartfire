import { Interactive } from './interactive.js';
import { hsvaToHslaString } from '../utils/convert.js';
import { createTemplate, createRoot } from '../utils/dom.js';
import { clamp, round } from '../utils/math.js';
import styles from '../styles/alpha.js';
const template = createTemplate(`<style>${styles}</style><div id="gradient"></div>`);
export class Alpha extends Interactive {
    constructor() {
        super();
        this.gradient = createRoot(this, template).querySelector('#gradient');
        this.setAttribute('aria-label', 'Alpha');
        this.setAttribute('aria-valuemin', '0');
        this.setAttribute('aria-valuemax', '1');
    }
    connectedCallback() {
        if (this.hasOwnProperty('hsva')) {
            const value = this.hsva;
            delete this['hsva'];
            this.hsva = value;
        }
    }
    get xy() {
        return false;
    }
    get hsva() {
        return this._hsva;
    }
    set hsva(hsva) {
        this._hsva = hsva;
        const colorFrom = hsvaToHslaString({ ...hsva, a: 0 });
        const colorTo = hsvaToHslaString({ ...hsva, a: 1 });
        const value = hsva.a * 100;
        this.gradient.style.backgroundImage = `linear-gradient(to right, ${colorFrom}, ${colorTo}`;
        this.setStyles({
            top: '50%',
            left: `${value}%`,
            color: hsvaToHslaString(hsva)
        });
        const v = round(value);
        this.setAttribute('aria-valuenow', `${v}`);
        this.setAttribute('aria-valuetext', `${v}%`);
    }
    getMove(interaction, key) {
        // Alpha always fit into [0, 1] range
        return { a: key ? clamp(this.hsva.a + interaction.left) : interaction.left };
    }
}
customElements.define('vc-alpha', Alpha);
//# sourceMappingURL=alpha.js.map