import { validHex } from '../utils/validate.js';
import { createTemplate, createRoot } from '../utils/dom.js';
const template = createTemplate('<slot><input part="input" spellcheck="false"></slot>');
// Escapes all non-hexadecimal characters including "#"
const escape = (hex) => hex.replace(/([^0-9A-F]+)/gi, '').substr(0, 6);
const $color = Symbol('color');
const $saved = Symbol('saved');
const $input = Symbol('saved');
const $update = Symbol('update');
export class HexInputBase extends HTMLElement {
    static get observedAttributes() {
        return ['color'];
    }
    get color() {
        return this[$color];
    }
    set color(hex) {
        this[$color] = hex;
        this[$update](hex);
    }
    connectedCallback() {
        const slot = createRoot(this, template).firstElementChild;
        const setInput = () => {
            let input = this.querySelector('input');
            if (!input) {
                // remove all child node if no input found
                let c;
                while ((c = this.firstChild)) {
                    this.removeChild(c);
                }
                input = slot.firstChild;
            }
            input.addEventListener('input', this);
            input.addEventListener('blur', this);
            this[$input] = input;
        };
        slot.addEventListener('slotchange', setInput);
        setInput();
        // A user may set a property on an _instance_ of an element,
        // before its prototype has been connected to this class.
        // If so, we need to run it through the proper class setter.
        if (this.hasOwnProperty('color')) {
            const value = this.color;
            delete this['color'];
            this.color = value;
        }
        else if (this.color == null) {
            this.color = this.getAttribute('color') || '';
        }
        else if (this[$color]) {
            this[$update](this[$color]);
        }
    }
    handleEvent(event) {
        const target = event.target;
        const { value } = target;
        switch (event.type) {
            case 'input':
                const hex = escape(value);
                this[$saved] = this.color;
                if (validHex(hex)) {
                    this.color = hex;
                    this.dispatchEvent(new CustomEvent('color-changed', { bubbles: true, detail: { value: '#' + hex } }));
                }
                break;
            case 'blur':
                if (!validHex(value)) {
                    this.color = this[$saved];
                }
        }
    }
    attributeChangedCallback(_attr, _oldVal, newVal) {
        if (this.color !== newVal) {
            this.color = newVal;
        }
    }
    [$update](hex) {
        if (this[$input]) {
            this[$input].value = hex == null || hex == '' ? '' : escape(hex);
        }
    }
}
//# sourceMappingURL=hex-input.js.map